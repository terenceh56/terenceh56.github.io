---
import {getCollectionByName} from "@/utils/getCollectionByName";
import getUniqueTags from "@/utils/getUniqueTags";
import getCountByCategory from "@/utils/getCountByCategory";
import HeaderLink from './HeaderLink.astro';
import ThemeIcon from './ThemeIcon.astro'
import MenuIcon from './MenuIcon.astro'
import {site, categories, infoLinks} from '@/consts';
import AsideIcon from "./SidebarIcon.astro";
import {t} from "@/i18n/utils";
import getCountByTagName from "@/utils/getCountByTagName";
import getUrl from "@/utils/getUrl";
// aggregate posts from multiple collections so counts still work after removing the "blog" category
let posts = [];
const collectionsToTry = ['blog', 'notes', 'thoughts', 'papers', 'feed'];
for (const col of collectionsToTry) {
  try {
    const c = await getCollectionByName(col);
    if (c && c.length) posts = posts.concat(c);
  } catch (err) {
    // ignore missing collections
  }
}
let tagArr = getUniqueTags(posts);
let categoryCount = getCountByCategory(posts);
let tagCount = getCountByTagName(posts);
const { hideNav = false } = Astro.props;
---

<header data-home={getUrl('/')} class="fixed top-0 z-50 w-full glass text-skin-base">
  <div class="container flex items-center justify-between">
    <div class="block xl:hidden">
      <MenuIcon></MenuIcon>
    </div>
    <a class="header-logo p-4 text-2xl flex items-center absolute left-1/2 transform -translate-x-1/2 xl:static xl:transform-none xl:left-auto" href={getUrl("/")}>
      <img src={getUrl(site.favicon)} alt={site.title} class="h-8 w-auto mr-3" />
      <span class="font-bold">{site.title}</span>
    </a>
    <div class="flex items-center">
      { !hideNav && (
        <div class="hidden xl:block">
          <div class="flex items-center pr-4 space-x-5">
            {
              categories.map(category => (
                <HeaderLink href={category.href} icon={category.iconClass} target={category.target ? category.target : '_self'} children={category.children ? category.children : []}>{category.name}</HeaderLink>
              ))
            }
          </div>
        </div>
      )}
      <ThemeIcon></ThemeIcon>

    </div>
  </div>
  { !hideNav && (
    <div id="mobile-menu" class="hidden pb-8 overflow-y-auto text-center" style="height: calc(100vh - 64px)">
    {
      categories.map((category) => (
        <div class="py-2">
          <a class=" hover:text-skin-active" href={getUrl(category.href)}>
            <i class={category.iconClass}/>
            <span>{category.name}</span>
          </a>
          {
            category.children && category.children.length > 0 &&
            <div class="divider-horizontal"></div>
          }
          <div class="space-y-4 text-sm">
            {
              category.children && category.children.map(sub =>
                (
                  <a class="block hover:text-skin-active" href={getUrl(sub.href)}>
                    <i class={sub.iconClass}/>
                    <span>{sub.name}</span>
                  </a>
                )
              )
            }
          </div>
        </div>
      ))
    }
    </div>
  )}
  { !hideNav && (
    <div id="personal-info" class="hidden pb-8 overflow-y-auto break-all" style="height: calc(100vh - 64px)">
    <img class="mx-auto my-4 avatar" src={getUrl(site.avatar)} alt="avatar"/>
    <div class="mb-2 text-center">{site.motto}</div>
    </div>

    </div>
  )}
</header>
<!-- Backdrop blur overlay for mobile menu -->
<div id="menu-backdrop" class="menu-backdrop"></div>
<script is:inline>
  (function(){
    try {
      const header = document.querySelector('header');
      const homepage = header && header.dataset ? header.dataset.home || '/' : '/';
      
      // If we navigated here from the homepage, perform drop animation once
      const fromHomepage = sessionStorage.getItem('fromHomepage');
      if (fromHomepage && header) {
        // only trigger drop if header hasn't already been dropped
        if (!header.classList.contains('header--drop') && !header.classList.contains('header--dropped')) {
          header.classList.add('header--drop');
          // after the CSS animation finishes, replace with a stable class so it won't re-run on later navigations
          const ANIM_DURATION = 360 + 80; // animation duration + delay in ms (matches CSS)
          setTimeout(() => {
            header.classList.remove('header--drop');
            header.classList.add('header--dropped');
          }, ANIM_DURATION + 40);
        }
        sessionStorage.removeItem('fromHomepage');
      } else if (header) {
        // if NOT coming from homepage, ensure header is clean (no animation classes)
        header.classList.remove('header--drop');
        header.classList.remove('header--up');
        // keep it visible by default
        header.classList.add('header--dropped');
      }

      // Intercept clicks to homepage to animate header up before navigating
      document.addEventListener('click', function(e){
        function toggleHidden(elements) {
            const header = document.querySelector('header');
            elements.forEach(el => {
              if (!el) return;
              
              // If element is currently hidden, just show it (remove hidden)
              if (el.classList.contains('hidden')) {
                el.classList.remove('hidden');
                return;
              }

              // If element is visible (not hidden), we want to close it with animation
              // Check if it's one of the elements that needs animation (menu or personal info)
              if (el.id === 'mobile-menu' || el.id === 'personal-info') {
                el.classList.add('closing');
                // If closing menu, slide header down (remove menu-open)
                if (el.id === 'mobile-menu') {
                  header?.classList.remove('menu-open');
                }
                
                // Wait for animation to finish before hiding
                // Match the longest animation duration (0.4s + 0.35s delay = 0.75s approx)
                // We'll use 800ms to be safe
                setTimeout(() => {
                  el.classList.add('hidden');
                  el.classList.remove('closing');
                }, 800);
              } else {
                // For other elements (icons etc), just toggle hidden immediately
                el.classList.add('hidden');
              }
            });
        }

        const a = e.target.closest && e.target.closest('a');
        const menuToggleBtn = e.target.closest('#menu-toggle-btn');
        const asideBtn = e.target.closest('#aside-btn');
        const asideCloseBtn = e.target.closest('#aside-close-btn');

        if (menuToggleBtn) {
            const menu = document.getElementById('mobile-menu');
            const personalInfo = document.getElementById('personal-info');
            const showAsideBtn = document.getElementById('aside-btn');
            const closeAsideBtn = document.getElementById('aside-close-btn');
            const header = document.querySelector('header');
            const backdrop = document.getElementById('menu-backdrop');

            // if personal info is shown, close it.
            if (personalInfo && !personalInfo.classList.contains('hidden')) {
                personalInfo.classList.add('closing');
                setTimeout(() => {
                  personalInfo.classList.add('hidden');
                  personalInfo.classList.remove('closing');
                }, 800);
                
                if (showAsideBtn) showAsideBtn.classList.remove('hidden');
                if (closeAsideBtn) closeAsideBtn.classList.add('hidden');
            }
            
            // Toggle menu
            if (menu.classList.contains('hidden')) {
              // Opening
              menu.classList.remove('hidden');
              header?.classList.add('menu-open');
              backdrop?.classList.add('active');
            } else {
              // Closing
              menu.classList.add('closing');
  
              // âœ… TRIGGER THE 0.8s FADE-OUT IMMEDIATELY 
              // (This is now synced with the menu's 0.8s exit animation)
              header?.classList.remove('menu-open');   
              backdrop?.classList.remove('active');    
              
              // Wait for the animation to finish before setting the 'hidden' state
              setTimeout(() => {
                menu.classList.add('hidden');
                menu.classList.remove('closing');
              }, 0);
            }
            return;
        } else if (asideBtn) {
            const menu = document.getElementById('mobile-menu');
            const personalInfo = document.getElementById("personal-info");
            const showAsideBtn = document.getElementById("aside-btn");
            const closeAsideBtn = document.getElementById("aside-close-btn");
            const header = document.querySelector('header');
            const backdrop = document.getElementById('menu-backdrop');
            
            // if menu is open, close it
            if (menu && !menu.classList.contains('hidden')) {
                menu.classList.add('closing');
                header?.classList.remove('menu-open');
                backdrop?.classList.remove('active');
                setTimeout(() => {
                  menu.classList.add('hidden');
                  menu.classList.remove('closing');
                }, 800);
            }
            
            // Open personal info
            personalInfo.classList.remove('hidden');
            showAsideBtn.classList.add('hidden');
            closeAsideBtn.classList.remove('hidden');
            return;
        } else if (asideCloseBtn) {
            const personalInfo = document.getElementById("personal-info");
            const showAsideBtn = document.getElementById("aside-btn");
            const closeAsideBtn = document.getElementById("aside-close-btn");
            
            // Close personal info
            personalInfo.classList.add('closing');
            showAsideBtn.classList.remove('hidden');
            closeAsideBtn.classList.add('hidden');
            setTimeout(() => {
              personalInfo.classList.add('hidden');
              personalInfo.classList.remove('closing');
            }, 800);
            return;
        }

        if(!a) return;
        const href = a.getAttribute('href');
        if(!href) return;
        const currentPath = window.location.pathname;
        const isHomepage = currentPath === '/' || currentPath === homepage;

        // If the clicked link points to homepage, animate header up (slide away)
        if (href === '/' || href === '' || href === homepage) {
          e.preventDefault();
          if (header && !header.classList.contains('header--up')) {
            // animate header up (slide away) before navigating
            header.classList.add('header--up');
            header.classList.remove('header--dropped');
          }
          setTimeout(function(){ window.location.href = href; }, 280);
        } else if (isHomepage) {
          // If currently on homepage and clicking a non-homepage link, set flag
          sessionStorage.setItem('fromHomepage', 'true');
        }
      });

      // Glassmorphic blur effect on scroll (only on non-homepage pages)
      const currentPath = window.location.pathname;
      const isHomepage = currentPath === '/' || currentPath === homepage;
      
      if (!isHomepage && header) {
        let ticking = false;
        const SCROLL_THRESHOLD = 50; // Activate blur after scrolling 50px

        function updateGlassEffect() {
          const scrollY = window.scrollY || window.pageYOffset;
          
          if (scrollY > SCROLL_THRESHOLD) {
            header.classList.add('glass--active');
          } else {
            header.classList.remove('glass--active');
          }
          
          ticking = false;
        }

        function onScroll() {
          if (!ticking) {
            window.requestAnimationFrame(updateGlassEffect);
            ticking = true;
          }
        }

        // Initial check in case page loads scrolled down
        updateGlassEffect();

        // Listen for scroll events
        window.addEventListener('scroll', onScroll, { passive: true });
      }
    } catch (err) { console.error(err); }
  })();
</script>
